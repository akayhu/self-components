# JavaScript 正則表達式

JavaScript 的特性借鑑許多語言：

- 文法：Java

- 函式：Schema

- 原型繼承：Self

- 正則表達式：Perl

可處理正則表達式的方法：

- regexp.exec

- regexp.test

- string.match

- string.replace

- string.search

- string.split

## 範例

### Parse URL

這邊有個範例要找對應分配的 URL。

```js
var parse_url =
	'/^(?:([A-Za-z+]:)?(/(0,3))([0-9.-A-Z-a-z]+)(?::(d+))?(?:/([^?#]*))?(?:?([^#]*))?(?:#(.*))?$/';

var url = 'https://www.ora.com:80/goodparts?q#frament';

var result = parse_url.exec(url);

var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];

var blanks = '  ';
var i;

for (i = 0; i < name.length; i += 1) {
	document.wrintIn(name[i] + ':' + blanks.substring(name[i].length), result[i]);
}
```

使用 `parse_url` 的 `exec` 方法，傳入字串比對成功則回傳擷取自 url 的零碎字串陣列。

得到結果如下

- url: https://www.ora.com:80/goodparts?q#frament

- sheme: http

- slash: //

- host: www.ora.com:80

- port: 80

- path: goodparts

- query: q

- hash: fragment

現在讓我們開始解析 parse\_ url ，

```js
var parse_url = /^(?:([A-Za-z+]:)?(\/(0,3))([0-9.\-A-Z-a-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
```

`^`：指出字串的開始，為一個定位點，阻止 exec 跳過不像 URL 的字首。

`(?:([A-Za-z+]:)?`：這個字段比對 scheme 名稱，名稱後面必須接:。

`(?:...)`：表示本段落非記憶集結，字尾? 表示該集結為選用集結。

`(...)`：括號表示一個記憶集結。選用：重複零或一次。

`[...]`：字元類組，以這次的[A-Za-z+]來說，就是包含二十六個大小寫字母。

`-`：指範圍連字號。

`+`：用於字元類組用於一或多次比對。這個群組緊接在:字元後，比對時將照字面如實比對。

記憶集結複製符合比對的文字，放到 result 變數中。每個記憶集結都拿到一個編號，假設某個記憶集結得到 1，符合這個記憶集結的文字複本會出現在 `result[1]`。

```js
(\/{0,3})
```

`\/` 比對是否有`/`斜線字元，它被\反斜線字元轉義，所以不會被翻譯為正規式實字的結尾。`{0,3}` 意指它前面的`/`可以出現 1~3 次。

```js
([0-9.\-A-Za-z]+)
```

比對 host，由一個或多個英數字元，加上「.」或「-」組成。`-` 需做轉義，表示為`\-`，避免誤解為範圍連字號。

```js
(?::(/d+))?
```

比對 port，接在字元後的數字序列。`\d` 表示數字字元。一或多個數字則是第四個記憶集結。

```js
(?:\/([^?#]*))?
```

選用性集結，開頭為`/`。

字元類組 `[^?#]` 起始為`^`，代表類組包含所有字元，但`?`與`#`除外。`*`則表示前面的字元類組應出現零或多次。

```js
(?:\?([^#]*))?
```

以`?`起始的選用集結，它包含第六個記憶集結，負責比對零或多個字元（不含#）。

```js
(?:#(.*))?
```

以`#`起始，「.」用於比對任何字元，但行末字元除外。

```js
$;
```

表示字串結尾，確保 URL 後沒有其他東西。

## Parse Number

```js
var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
var test = function(num) {
	document.writeln(parse_number.test(num));
};
test('l'); //true
test('number'); //false
test('98.6'); //true
test('132.21.86.100'); //false
test('123.45E-67'); //true
test('123.45D-67'); //false
```

parse_number 可以分辨符合規格和不符合的字串，但看不出來哪裡不符合，那現在來分解：

```js
/^     $/I
```

看到定位點`^`和`$`，所以字串中的所有字元要跟正規式比對。

省略定位點，正規表示字串中是否包含數字；

有了定位點，正規表示字串中是否只有數字。

如果採用 `^`，可對出以數字起始的字串，

如果採用 `$`，可對出以數字結尾的字串。

i 找到相符合文字，忽略大小寫的差異，樣式中唯一一個字元就是 e，我們希望 e 也能找出 E，這個部分寫成 [Ee] 或 (?:E|e) ，也可以達到相同效果。

```js
-?
```

負號（-）後的字尾，表示負號為選用。

```js
\d+
```

`\d` 與`[0-9]` 相同，用來比對數字。字尾`+` 要求前面的數字出現一次或多次。

```js
(?:\.|d*)?
```

`(?:...)`表示一個非記憶集結。

```js
(?:...)
```

也是一個非記憶集結，可比對出 e 或 (E)，加上選用正負號，以及一或多個數字。

## 建構

正規式實字：由一對斜線圍起。

對 RegExp 可設置三個旗標，分別以 g、i、m 代表，旗標直接附加在正規實字後方。

- g：全域，比對多次。

- i：鈍感，忽略字元大小寫。

- m：多行，^ 與 \$ 能比對行末字元。

```js
var my_regexp = /"(?:\\.|[^\\\""])*"/g;
```

【 建構式 】

構式接受傳入字串，並編譯成 RegExp 物件。

```js
var my_regexp = new RegExp('"(?:\\.|[^\\\\\\"])*"', 'g');
```

- 建字串需要額外注意反斜線各自有不同意義，須以引號轉義。

- 第二個參數為指定旗標的字串。

## RegExp 物件的特性

global：使用 `g` 時為 true。

ignoreCase：使用 `i` 時為 true。

lastIndex：開始下一輪 exec 比對時為 true。

muliline：使用 `m` 時為 true。

source：正規式來源字元。

## 以 RegExp 物件共享實例：

```js
function make_a_matcher() {
	return /a/gi;
}

var x = make_a_matcher();
var y = make_a_matcher();
x.lastIndex = 10;
console.log(y.lastIndex); //10
```

## 零件

### 正規式選項

包含一至多個正規式序列。

序列以|字元區分。

```js
'into.match(/in|int/)';
```

從 into 中找出 in 就不會再找 int 了。

## 正規式序列

包含一至多個正規式要素。

每個正規式都能選用性地後街量詞，如果沒量詞表示只需比對一次。

## 正規式要素

可能是字元、集結、字元類組，或是轉義序列。

所有字元都被視為實字，除了控制字元和特殊字元：

- \ / [ ]() { } ? + \\\\\\\\* | . ^ \$

- 如果想比對上述字元必須加上\。

- 特殊字元加上\都能變為實字，但\無法讓英文變實字。

未轉義的.可以比對任何字元，行末字元例外。

未轉義的^可以比對字串始處，但 lastIndex 特性需為 0，若指定旗標 m 亦可以把行末字元納入比對。

未轉義的\$可以比對字串尾處，若指定旗標 m 亦可以把行末字元納入比對。

## 正規式轉義

`\` 在正規要素及字串中皆表示轉義，但在正規要素的運作稍微不同。

`\f`：與在字串相同，表示換頁字元

`\n`：表示換行字元。

`\r`：表示游標歸位（列首）字元。

`\t`：表 tab 字元。

`\u`：表示十六進位常數，來指定 unicode 字元。

`\b`：在正規式中，不表示為倒退字元。

`\d`：與[0-9]意思相同；\D：為前者反義，與[^0-9]相同，比對非數字字元。

`\s` 與 [\f\n\r\t\u000B\u0020\u00A0\2028\u2029] 同義；\S 與前者反義，與 [^\f\n\r\t\u000b\u0020\u00a0\2028\u2029] 同義。

`\w` 與 [0-9A-Z_a-z] 意思相同，能比對所有英數字元；\W 與前者反義，與 [^0-9a-z_a-z] 同義。（/w 應該代表組成詞彙的一組字元。）

`\b` 設計為字詞邊界的定位點，它使用/w 尋找字詞邊界，對於多國語系無效，這不算優良部份。

## 正規式集結

記憶集結：記憶集結是以括號圍起的正規式選項。每個記憶集結都有編號，第一個左括號為第一個集結，第二個左括號是第二個集結。

非記憶集結：多了(?，非記憶集結只單純做比對，不記憶符合的文段。

右合樣集結：多了(?=字首，比對出集結的文段後，又再回到集結開始的地方，無法比對東西，他也不算優良部份。

右不合樣集結：多了(?!字首，無法比對東西才成功，他也不算優良部份。

## 其他規則

正規式類組：是用來指定一組字元的便利方式。例如：(?:a|e|i|o|u) 可以寫成[aeiou]。

正規式類組轉義：與一般正規轉義規則不太相同。[\b]意思是倒退字元。

正規式量詞：正規式要素後接正規式量詞，以決定要素與比對次數，大括號圍起的數字就是要比對的次數。

- /www/ ：等同於 /w{3}/。

- {3,6}：比對三、四、五或六次。

- {3,}：可比對三次以上。

- ?：等同於 {0,1}。

- \*：等同於 {0,}。

- +：等同於 {1,}。

## 出處

[JavaScript 設計模式 優良部份 Chapter07 正則表達式](https://ithelp.ithome.com.tw/articles/10209312)
